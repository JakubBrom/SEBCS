# -*- coding: utf-8 -*-
"""
/***************************************************************************
 SEBCS
								 A QGIS plugin
 Module for calculation of energy balance features and vegetation water stress indices
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
							  -------------------
		begin                : 2019-03-06
		git sha              : $Format:%H$
		copyright            : (C) 2019 by Jakub Brom, University of South Bohemia in Ceske Budejovice, Faculty of Agriculture
		email                : jbrom@zf.jcu.cz
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

# Imports
import os
import time
import urllib
import sys
import os.path

# Import PyQt libs
from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication, QDate, QTime, Qt, QThread, QUrl
from PyQt5.QtGui import QIcon, QDesktopServices
from PyQt5.QtWidgets import QAction, QFileDialog, QProgressBar, QPushButton
from qgis.gui import QgsMessageBar
from qgis.core import QgsProject, Qgis
import qgis.utils as ut

# Import geolibrary
from osgeo import gdal, osr, ogr

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .SEBCS_dialog import SEBCSDialog

# Import SEBCS core
from sebcs.scripts import SEBCS_SA as scs

class SEBCS:
	"""QGIS Plugin Implementation."""

	def __init__(self, iface):
		"""Constructor.

		:param iface: An interface instance that will be passed to this class
			which provides the hook by which you can manipulate the QGIS
			application at run time.
		:type iface: QgsInterface
		"""
		# Save reference to the QGIS interface
		self.iface = iface
		# initialize plugin directory
		self.plugin_dir = os.path.dirname(__file__)
		# initialize locale
		locale = QSettings().value('locale/userLocale')[0:2]
		locale_path = os.path.join(
			self.plugin_dir,
			'i18n',
			'SEBCS_{}.qm'.format(locale))

		if os.path.exists(locale_path):
			self.translator = QTranslator()
			self.translator.load(locale_path)

			if qVersion() > '4.3.3':
				QCoreApplication.installTranslator(self.translator)

		# Declare instance attributes
		self.actions = []
		self.menu = self.tr(u'&SEBCS for QGIS')

		# Check if plugin was started the first time in current QGIS session
		# Must be set in initGui() to survive plugin reloads
		self.first_start = None

	# noinspection PyMethodMayBeStatic
	def tr(self, message):
		"""Get the translation for a string using Qt translation API.

		We implement this ourselves since we do not inherit QObject.

		:param message: String for translation.
		:type message: str, QString

		:returns: Translated version of message.
		:rtype: QString
		"""
		# noinspection PyTypeChecker,PyArgumentList,PyCallByClass
		return QCoreApplication.translate('SEBCS', message)


	def add_action(
		self,
		icon_path,
		text,
		callback,
		enabled_flag=True,
		add_to_menu=True,
		add_to_toolbar=True,
		status_tip=None,
		whats_this=None,
		parent=None):
		"""Add a toolbar icon to the toolbar.

		:param icon_path: Path to the icon for this action. Can be a resource
			path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
		:type icon_path: str

		:param text: Text that should be shown in menu items for this action.
		:type text: str

		:param callback: Function to be called when the action is triggered.
		:type callback: function

		:param enabled_flag: A flag indicating if the action should be enabled
			by default. Defaults to True.
		:type enabled_flag: bool

		:param add_to_menu: Flag indicating whether the action should also
			be added to the menu. Defaults to True.
		:type add_to_menu: bool

		:param add_to_toolbar: Flag indicating whether the action should also
			be added to the toolbar. Defaults to True.
		:type add_to_toolbar: bool

		:param status_tip: Optional text to show in a popup when mouse pointer
			hovers over the action.
		:type status_tip: str

		:param parent: Parent widget for the new action. Defaults None.
		:type parent: QWidget

		:param whats_this: Optional text to show in the status bar when the
			mouse pointer hovers over the action.

		:returns: The action that was created. Note that the action is also
			added to self.actions list.
		:rtype: QAction
		"""

		icon = QIcon(icon_path)
		action = QAction(icon, text, parent)
		action.triggered.connect(callback)
		action.setEnabled(enabled_flag)

		if status_tip is not None:
			action.setStatusTip(status_tip)

		if whats_this is not None:
			action.setWhatsThis(whats_this)

		if add_to_toolbar:
			# Adds plugin icon to Plugins toolbar
			self.iface.addToolBarIcon(action)

		if add_to_menu:
			self.iface.addPluginToMenu(
				self.menu,
				action)

		self.actions.append(action)

		return action

	def initGui(self):
		"""Create the menu entries and toolbar icons inside the QGIS GUI."""

		icon_path = ':/plugins/SEBCS/icon.png'
		self.add_action(
			icon_path,
			text=self.tr(u'SEBCS'),
			callback=self.run,
			parent=self.iface.mainWindow())

		# will be set False in run()
		self.first_start = True
		# Create the dialog with elements (after translation) and keep reference
		# Only create GUI ONCE in callback, so that it will only load when the plugin is started
		if self.first_start == True:
			self.first_start = False
			self.dlg = SEBCSDialog()

		# Set path to selected raster files to CBoxes - for each one
		self.dlg.b_blue.clicked.connect(lambda: self.selectFile(self.dlg.cb_blue))
		self.dlg.b_green.clicked.connect(lambda: self.selectFile(self.dlg.cb_green))
		self.dlg.b_red.clicked.connect(lambda: self.selectFile(self.dlg.cb_red))
		self.dlg.b_nir.clicked.connect(lambda: self.selectFile(self.dlg.cb_nir))
		self.dlg.b_swir1.clicked.connect(lambda: self.selectFile(self.dlg.cb_swir1))
		self.dlg.b_swir2.clicked.connect(lambda: self.selectFile(self.dlg.cb_swir2))
		self.dlg.b_ts_layer.clicked.connect(lambda: self.selectFile(self.dlg.cb_ts_layer))
		self.dlg.b_dmt.clicked.connect(lambda: self.selectFile(self.dlg.cb_dmt))
		self.dlg.b_ta.clicked.connect(lambda: self.selectFile(self.dlg.cb_ta))
		self.dlg.b_wind.clicked.connect(lambda: self.selectFile(self.dlg.cb_wind))
		self.dlg.b_hmin.clicked.connect(lambda: self.selectFile(self.dlg.cb_hmin))
		self.dlg.b_hmax.clicked.connect(lambda: self.selectFile(self.dlg.cb_hmax))
		self.dlg.b_canopy.clicked.connect(lambda: self.selectFile(self.dlg.cb_canopy))
		self.dlg.b_mask.clicked.connect(lambda: self.selectFile(self.dlg.cb_mask))
		self.dlg.b_albedo.clicked.connect(lambda: self.selectFile(self.dlg.cb_albedo))
		
		# Set path to output folder
		self.dlg.b_out_folder.clicked.connect(self.outFolder)
		
		self.out_folder_path = "/home"
		
		#if self.dlg.cb_methods.currentIndex() == 0:
		self.dlg.ch_canopy.toggled.connect(lambda: self.setCboxEmpty(self.dlg.cb_hmin))
		self.dlg.ch_canopy.toggled.connect(lambda: self.setCboxEmpty(self.dlg.cb_hmax))
		
		# Set canopy heigth CBox empty
		self.dlg.ch_canopy.toggled.connect(lambda: self.setCanopyEmpty(self.dlg.cb_canopy))
		
		
		# Set unchecked friction velocity if the gradient method is used
		#self.dlg.rb_grad.toggled.connect(self.frictUncheck)
		self.dlg.ch_all.toggled.connect(self.frictUncheck)	 
		
		# Set disabled multiband setting
		self.dlg.cb_out_format.currentIndexChanged.connect(self.setMultibandDisabled)
		
		# Set latitude and longitude from NIR band
		self.dlg.b_auto_latlong.clicked.connect(lambda: self.latLong())
		
		# Checkbox list for output layers - for testing if they are cheked or no.
		self.out_chbox_list = [self.dlg.ch_rs_in,
							self.dlg.ch_rs_out,
							self.dlg.ch_albedo,
							self.dlg.ch_rl_in,
							self.dlg.ch_rl_out,
							self.dlg.ch_rn,
							self.dlg.ch_ts,
							self.dlg.ch_emiss,
							self.dlg.ch_le,
							self.dlg.ch_le_pen,
							self.dlg.ch_le_pt,
							self.dlg.ch_sensible,
							self.dlg.ch_ground,
							self.dlg.ch_e_int,
							self.dlg.ch_ef,
							self.dlg.ch_bowen,
							self.dlg.ch_omega,
							self.dlg.ch_cwsi,
							self.dlg.ch_frict,
							self.dlg.ch_ra,
							self.dlg.ch_rc,
							self.dlg.ch_ndvi,
							self.dlg.ch_msavi,
							self.dlg.ch_ndmi,
							self.dlg.ch_slope,
							self.dlg.ch_aspect]
							

		# Reset content of the form
		self.dlg.buttonBox.rejected.connect(self.reset)
		
		# Help
		self.dlg.buttonBox.helpRequested.connect(self.pluginHelp)
		
		# GUI settings according to selected calculation method
		self.dlg.cb_methods.currentIndexChanged.connect(self.methodsGuiSet)
		
		# GUI settings according to selected imaging systems
		self.dlg.cb_systems.currentIndexChanged.connect(self.systemsGuiSet)
		
		
	def methodsGuiSet(self):
		"""GUI settings according to selected calculation method"""

		if self.dlg.cb_methods.currentIndex() == 1:
			# set widgets disabled
			self.dlg.ch_canopy.setChecked(False)
			self.dlg.dsb_hwind.setDisabled(True)
			
			self.dlg.ch_frict.setDisabled(True)
			self.dlg.ch_canopy.setDisabled(True)
			
			self.dlg.cb_wind.setDisabled(True)
			self.dlg.cb_hmin.setDisabled(True)
			self.dlg.cb_hmax.setDisabled(True)
			self.dlg.cb_canopy.setDisabled(True)
			
			self.dlg.b_wind.setDisabled(True)
			self.dlg.b_hmin.setDisabled(True)
			self.dlg.b_hmax.setDisabled(True)
			self.dlg.b_canopy.setDisabled(True)
			
			self.dlg.label_19.setDisabled(True)
			self.dlg.label_20.setDisabled(True)
			self.dlg.label_21.setDisabled(True)
			self.dlg.label_26.setDisabled(True)
			self.dlg.label_14.setDisabled(True)
			
			# clear widgets
			self.dlg.dsb_hwind.setValue(0.0)
			
			self.dlg.ch_frict.setChecked(False)
			
			self.dlg.cb_wind.setCurrentIndex(0)
			self.dlg.cb_hmin.setCurrentIndex(0)
			self.dlg.cb_hmax.setCurrentIndex(0)
			self.dlg.cb_canopy.setCurrentIndex(0)
		else:
			# enabled widgets
			self.dlg.dsb_hwind.setEnabled(True)
			
			self.dlg.ch_frict.setEnabled(True)
			self.dlg.ch_canopy.setEnabled(True)
			
			self.dlg.cb_wind.setEnabled(True)
			self.dlg.cb_hmin.setDisabled(True)
			self.dlg.cb_hmax.setDisabled(True)
			self.dlg.cb_canopy.setEnabled(True)
			
			self.dlg.b_wind.setEnabled(True)
			self.dlg.b_hmin.setDisabled(True)
			self.dlg.b_hmax.setDisabled(True)
			self.dlg.b_canopy.setEnabled(True)
			
			self.dlg.label_19.setEnabled(True)
			self.dlg.label_20.setEnabled(True)
			self.dlg.label_21.setEnabled(True)
			self.dlg.label_26.setEnabled(True)
			self.dlg.label_14.setEnabled(True)
			
			self.dlg.ch_frict.setChecked(True)
			self.dlg.ch_canopy.setChecked(True)
			
			self.dlg.dsb_hwind.setValue(10.0)

	
	def systemsGuiSet(self):
		"""GUI settings according to selected imaging systems"""
		
		if self.dlg.cb_systems.currentIndex() > 2:
			# set disbaled unused widgets
			self.dlg.cb_blue.setDisabled(True)
			self.dlg.cb_green.setDisabled(True)
			self.dlg.cb_swir1.setDisabled(True)
			self.dlg.cb_swir2.setDisabled(True)
			self.dlg.label_3.setDisabled(True)
			self.dlg.label_4.setDisabled(True)
			self.dlg.label_7.setDisabled(True)
			self.dlg.label_8.setDisabled(True)
			self.dlg.b_blue.setDisabled(True)
			self.dlg.b_green.setDisabled(True)
			self.dlg.b_swir1.setDisabled(True)
			self.dlg.b_swir2.setDisabled(True)
			# set clear cboxes
			self.dlg.cb_blue.setCurrentIndex(0)
			self.dlg.cb_green.setCurrentIndex(0)
			self.dlg.cb_swir1.setCurrentIndex(0)
			self.dlg.cb_swir2.setCurrentIndex(0)

		else:
			# set widgets enabled
			self.dlg.cb_blue.setEnabled(True)
			self.dlg.cb_green.setEnabled(True)
			self.dlg.cb_swir1.setEnabled(True)
			self.dlg.cb_swir2.setEnabled(True)
			self.dlg.label_3.setEnabled(True)
			self.dlg.label_4.setEnabled(True)
			self.dlg.label_7.setEnabled(True)
			self.dlg.label_8.setEnabled(True)
			self.dlg.b_blue.setEnabled(True)
			self.dlg.b_green.setEnabled(True)
			self.dlg.b_swir1.setEnabled(True)
			self.dlg.b_swir2.setEnabled(True)


	def setMethod(self):
		"""Definition of calculation method"""
		
		if self.dlg.cb_methods.currentIndex() == 0:
			rb_method = "aero"
		else:
			rb_method = "grad"
		
		return rb_method


	def unload(self):
		"""Removes the plugin menu item and icon from QGIS GUI."""
		for action in self.actions:
			self.iface.removePluginMenu(
				self.tr(u'&SEBCS for QGIS'),
				action)
			self.iface.removeToolBarIcon(action)


	def run(self):
		"""Run method that performs all the real work"""

		
		# List of names in QGIS legend and paths to files
		self.lyrs, self.lyrs_path = self.addRasterLyrs()

		# Adding the list of layers names to cboxes
		self.dlg.cb_blue.addItems(self.lyrs)
		self.dlg.cb_green.addItems(self.lyrs)
		self.dlg.cb_red.addItems(self.lyrs)
		self.dlg.cb_nir.addItems(self.lyrs)
		self.dlg.cb_swir1.addItems(self.lyrs)
		self.dlg.cb_swir2.addItems(self.lyrs)
		self.dlg.cb_ts_layer.addItems(self.lyrs)
		self.dlg.cb_dmt.addItems(self.lyrs)
		self.dlg.cb_ta.addItems(self.lyrs)
		self.dlg.cb_wind.addItems(self.lyrs)
		self.dlg.cb_hmin.addItems(self.lyrs)
		self.dlg.cb_hmax.addItems(self.lyrs)
		self.dlg.cb_canopy.addItems(self.lyrs)
		self.dlg.cb_mask.addItems(self.lyrs)
		self.dlg.cb_albedo.addItems(self.lyrs)
		
		# Set current date and time
		self.dlg.dateEdit.setDate(QDate.currentDate())
		self.dlg.timeEdit.setTime(QTime.currentTime())
		
		self.dlg.show()
		
		# Run the dialog event loop
		result = self.dlg.exec_()
		# See if OK was pressed
		if result:
			
			try:
				# Setting of the inputs
				self.setInputs()

				# Condition - calculation according to the output path 
				if self.out_folder_path != None and self.out_folder_path != "":
					
					# Creating of log file
					self.settingsLog()
					
					# Check the completness of the form filling
					ch_form = self.checkForm()
									
					# Check for differences in layers spatial extent
					lyr_ext = self.lyrsExtent()
	
					# Condition - testing of the for fullness and layers extent
					if lyr_ext == True and ch_form == True:
						# Start progress bar
						self.progbar()
						
						# Run SEBCS calculation
						self.WT = WorkingThread(self.calculate)
						self.WT.taskFinished.connect(self.onFinished)
						
						self.onStart()
						
					else:
						#self.iface.messageBar().pushMessage("Error", "Ooops, an error has occur during calculation...", level = QgsMessageBar.CRITICAL)	
						self.reset()
						
				else:
					self.iface.messageBar().pushMessage(self.tr("Warning"), self.tr("No output path has been selected. Try it again."), level = Qgis.Warning)
					self.reset()
					
			except:
				self.iface.messageBar().pushMessage("Error", "Ooops, an error has occur during calculation...", level = Qgis.Critical)
				self.reset()


	def pluginHelp(self):
		"""Open the help file.
		"""
		self.help_file = os.path.join(self.plugin_dir, "help", "build", "html", "index.html")
		try:
			#if sys.platform == 'linux2':
			QDesktopServices.openUrl(QUrl(self.help_file))
			#else:
			#	os.startfile(self.help_file)			
		except:
			self.iface.messageBar().pushMessage(self.tr("Help error"),
								self.tr("Ooops, an error occured during help file opening..."),
								level =  Qgis.Warning, duration = 5)
		
	def selectFile(self, comboBox):
		"""
		Opening the raster layer file and adding the path to the combobox
		on end of the list with comboBox items.
		
		:param comboBox: Qt combobox.
		:type comboBox: QComboBox
		"""

		ind = comboBox.count()
		
		if len(self.lyrs) != ind:
			comboBox.removeItem(ind - 1)
		else:
			pass
		
		try:
			rast_path = QFileDialog.getOpenFileName(None,
								self.tr("Select file"), self.out_folder_path,
								"Images (*.*);; GeoTIFF (*.tif);; Idrisi Raster (*.rst);; Erdas Imagine (*.img);; GDAL Virtual (*.vrt);; ENVI (*.hdr)")
			self.out_folder_path, filename = os.path.split(rast_path)
						
			comboBox.addItem(str(rast_path))
			comboBox.setCurrentIndex(len(self.lyrs))
		except:
			self.iface.messageBar().pushMessage(self.tr("Path error"),
								self.tr("Selected path contains probably diacritics or spaces.\nTry it again."),
								level =  Qgis.Warning)
			comboBox.setCurrentIndex(0)

	
	def pathToLyr(self, comboBox):
		"""Path to layer"""
		c_ind = comboBox.currentIndex()
		if c_ind > len(self.lyrs) - 1:
			lyr_path = comboBox.currentText()
		else:
			lyr_path = self.lyrs_path[c_ind]
			
		return lyr_path
			
		
	def addRasterLyrs(self):
		"""Insert list of rasters from GQIS layers panel to the combobox item list.
		The first value is empty ("")."""
		
		lyrs = [""]									# list of output layers names
		lyrs_path = [""]							# list of output layers paths
		layers = QgsProject.instance().mapLayers().values()		# nacte seznam vrstev z QGIS legendy --> vsechny, i neaktivni vrstvy
		for i in layers:
			if i.type() == 1:						# type 0 je vektor, type 1 je raster
				lyr_name = i.name()					# vypise jmeno vrstvy
				lyr_path = i.source()           	# vypise cestu k vrstve
				lyrs.append(lyr_name)           
				lyrs_path.append(lyr_path)
		
		return lyrs, lyrs_path
			

	def reset(self):
		"""Clear all fields and set original settings"""
		
		self.dlg.cb_blue.clear()
		self.dlg.cb_green.clear()
		self.dlg.cb_red.clear()
		self.dlg.cb_nir.clear()
		self.dlg.cb_swir1.clear()
		self.dlg.cb_swir2.clear()
		self.dlg.cb_ts_layer.clear()
		self.dlg.cb_dmt.clear()
		self.dlg.cb_ta.clear()
		self.dlg.cb_wind.clear()
		self.dlg.cb_hmin.clear()
		self.dlg.cb_hmax.clear()
		self.dlg.cb_canopy.clear()
		self.dlg.cb_mask.clear()
		self.dlg.cb_albedo.clear()
		self.dlg.cb_methods.setCurrentIndex(0)
		self.dlg.cb_systems.setCurrentIndex(0)
		
		self.dlg.dsb_global.setValue(0.0)
		self.dlg.dsb_humid.setValue(0.0)
		self.dlg.dsb_hwind.setValue(10.0)
		self.dlg.dsb_lat.setValue(0.0)
		self.dlg.dsb_long.setValue(0.0)
		self.dlg.dateEdit.clear()
		self.dlg.timeEdit.clear()
		
		self.dlg.le_out_folder.clear()					
		
		self.dlg.ch_all.setChecked(True)				# clear selection for output files - set all button
		for i in self.out_chbox_list:					# clear all outputs
			i.setChecked(True)
		
		self.dlg.cb_out_format.setCurrentIndex(3)		# setting of GTiff as primary output type
		

	def setCboxEmpty(self, comboBox):
		"""Setting of empty value (text) in comboBoxes"""
		comboBox.setCurrentIndex(0)
		
	
	def outFolder(self):
		self.dlg.le_out_folder.clear()
		try:
			self.out_folder_path = QFileDialog.getExistingDirectory(None, 
												self.tr("Select output folder"),
												self.out_folder_path)
			self.dlg.le_out_folder.setText(str(self.out_folder_path))
			
		except:
			self.iface.messageBar().pushMessage(self.tr("Path error"),
										self.tr("Selected path contains probably diacritics or spaces. Try it again."), 
										level =  Qgis.Warning)
	
			
	def getOutputName(self):
		"""Selection of the multiband or singleband output and multiband
		 output layer name.
		"""
		
		if self.dlg.ch_multi.isChecked():
			multiband = True
			out_file_name = self.dlg.le_out_name.text()
		else:
			multiband = False
			out_file_name = None
			
		return multiband, out_file_name
	
	
	def setMultibandDisabled(self):
		""" Set disabled multiband output for RST otput format.
		"""
		
		cur_ind = self.dlg.cb_out_format.currentIndex()
		if cur_ind == 2:
			self.dlg.ch_multi.setChecked(False)
			self.dlg.ch_multi.setDisabled(True)
		else:
			self.dlg.ch_multi.setEnabled(True)

	
	def frictUncheck(self):
		"""Set unchecked friction velocity if the gradient method is used.
		"""
	
		if self.dlg.cb_methods.currentIndex() == 1:
			self.dlg.ch_frict.setChecked(False)
			if self.dlg.ch_all.isChecked():
				self.dlg.ch_frict.setChecked(False)
			
	
	def setCanopyEmpty(self, comboBox):
		if self.dlg.ch_canopy.isChecked():
			pass
		else:
			comboBox.setCurrentIndex(0)
	
	
	def latLong(self):
		"""Automatic setting of the lyrs coordinates according to the
		projection of NIR band in to the form."""
		
		self.nir_path = self.pathToLyr(self.dlg.cb_nir)
		
		if self.nir_path == "":
			  self.iface.messageBar().pushMessage(self.tr("Info"), 
							self.tr("Select the NIR band first. Try it again."),
							level =  Qgis.Warning)
		else:
			try:
				ds = gdal.Open(self.nir_path)
				gtransf = ds.GetGeoTransform()
				leftCornerX = gtransf[0] 						# X position of left corner of the layer
				leftCornerY = gtransf[3]						# Y position of left corner of the layer
				xSize = gtransf[1]								# pixel X size
				ySize = gtransf[5]								# pixel Y size
				cols = ds.RasterXSize							# No. of columns
				rows = ds.RasterYSize							# No. of rows
				
				pointX = leftCornerX + (xSize*cols)/2			# X position of the middle of the layer
				pointY = leftCornerY + (ySize*rows)/2			# Y position of the middle of the layer
				
				prj = ds.GetProjection()
				
				ds = None
								
				# Spatial Reference System
				srs=osr.SpatialReference(wkt=prj)
				if srs.IsProjected:
					inputEPSG = int(srs.GetAttrValue("authority", 1))
				
				outputEPSG = int(4326)				# WGS84
				
				# create a geometry from coordinates
				point = ogr.Geometry(ogr.wkbPoint)
				point.AddPoint(pointX, pointY)
				
				# create coordinate transformation
				inSpatialRef = osr.SpatialReference()
				inSpatialRef.ImportFromEPSG(inputEPSG)
				
				outSpatialRef = osr.SpatialReference()
				outSpatialRef.ImportFromEPSG(outputEPSG)
				
				coordTransform = osr.CoordinateTransformation(inSpatialRef, outSpatialRef)
				
				# transform point
				point.Transform(coordTransform)
				
				# Coords in EPSG 4326
				self.long_dec = point.GetX()
				self.lat_dec = point.GetY()
				
				# Insert coords into the form		
				self.dlg.dsb_lat.setValue(self.lat_dec)
				self.dlg.dsb_long.setValue(self.long_dec)
			
			except:
				self.iface.messageBar().pushMessage(self.tr("Info"), 
										self.tr("Selected NIR band has probably no spatial reference. Set the spatial reference manually."),
										level =  Qgis.Warning)
		
	
	def lyrsExtent(self):
		"""Check differences between number of columns and rows in the input 
		rasters
		"""

		self.in_lyrs_list_true = [i for i in self.in_lyrs_list if i != None and i != ""]	# List of input rasters without empty paths
		 
		lcols = []									# No. of columns in the layers
		lrows = []									# No. of rows in the layers

		for i in self.in_lyrs_list_true:
			ds = gdal.Open(i)
			cols = ds.RasterXSize					# No. of columns
			rows = ds.RasterYSize					# No. of rows
			ds = None
			lcols.append(cols)
			lrows.append(rows)
		
		try:
			if max(lcols) > min(lcols) and max(lrows) > min(lrows):
				self.iface.messageBar().pushMessage(self.tr("Warning"), 
										self.tr("Selected raster layers differ in spatial extent (number of columns or rows). Please, try it again."),
										level =  Qgis.Warning)
				return False
			
			else:
				return True
		
		except:
			self.iface.messageBar().pushMessage(self.tr("Warning"), 
										self.tr("No raster layers has been probably selected. Please, try it again."),
										level =  Qgis.Warning)
			return False
	
		
	def checkForm(self):
		"""Check the completness of the input SEBCS form filling, 
		i.e. if the required items are set.
		"""

		check_state = True		
		
		if self.red_path == None or self.red_path == "":
			self.iface.messageBar().pushMessage(self.tr("Warning"), 
								self.tr("Red band has not been selected. Please, try it again."),
								level =  Qgis.Warning)
			check_state = False
			
		if self.nir_path == None or self.nir_path == "":
			self.iface.messageBar().pushMessage(self.tr("Warning"),
								self.tr("NIR band has not been selected. Please, try it again."),
								level =  Qgis.Warning)
			check_state = False
			
		if self.thermal_path == None or self.thermal_path == "":
			self.iface.messageBar().pushMessage(self.tr("Warning"), 
								self.tr("Thermal layer has not been selected. Please, try it again."),
								level =  Qgis.Warning)
			check_state = False
			
		if self.dmt_path == None or self.dmt_path == "":
			self.iface.messageBar().pushMessage(self.tr("Warning"),
								self.tr("DMT layer has not been selected. Please, try it again."),
								level =  Qgis.Warning)
			check_state = False
			
		if self.ta_path == None or self.ta_path == "":
			self.iface.messageBar().pushMessage(self.tr("Warning"), 
								self.tr("Air temperature layer has not been selected. Please, try it again."), 
								level =  Qgis.Warning)
			check_state = False
			
		if self.rb_method == "aero":
			if self.wind_path == None or self.wind_path == "":
				self.iface.messageBar().pushMessage(self.tr("Warning"), 
								self.tr("Wind speed layer has not been selected. Please, try it again."),
								level =  Qgis.Warning)
				check_state = False
			
			if self.canopy_path is None or self.canopy_path == "":
				if self.hmin_path == None or self.hmin_path == "":
					self.iface.messageBar().pushMessage(self.tr("Warning"), 
									self.tr("Layer of minimal canopy height has not been selected. Please, try it again."), 
									level =  Qgis.Warning)
					check_state = False
					
				if self.hmax_path == None or self.hmax_path == "":
					self.iface.messageBar().pushMessage(self.tr("Warning"), 
									self.tr("Layer of maximal canopy height has not been selected. Please, try it again."), 
									level =  Qgis.Warning)
					check_state = False
			
			if self.hmin_path == None or self.hmin_path == "" or self.hmax_path == None or self.hmax_path == "":
				if self.canopy_path is None or self.canopy_path == "":
					self.iface.messageBar().pushMessage(self.tr("Warning"), 
									self.tr("Layer of canopy height has not been selected. Please, try it again."), 
									level =  Qgis.Warning)
					check_state = False
				
		if len(self.out_lyrs_descr) == 0:
			self.iface.messageBar().pushMessage(self.tr("Warning"), 
								self.tr("No output layers have been selected. Try it again."),
								level = Qgis.Warning)
			check_state = False
			
		if self.out_folder_path == None or self.out_folder_path == "":
			self.iface.messageBar().pushMessage(self.tr("Warning"), 
								self.tr("No output path has been selected. Try it again."),
								level = Qgis.Warning)
			check_state = False
			
		return check_state
		
		
	def outputsList(self):
		"""Creation of output layers names list for the log.
		"""
		
		self.out_lyrs_list = []					# Boolean list for output lyrs --> receiving function should have correct order
		self.out_lyrs_descr = []				# List of names for selected variables
		self.out_lyrs_fnames = []				# List of names for selected output files
		
		# Names of all the output variables
		self.out_names_all = [self.tr("Incoming shortwave radiation (W.m-2)"),
							self.tr("Reflected shortwave radiation (W.m-2)"),
							self.tr("Albedo (rel.)"),
							self.tr("Incoming longwave radiation (W.m-2)"),
							self.tr("Reflected longwave radiation (W.m-2)"),
							self.tr("Total net radiation (W.m-2)"),
							self.tr("Surface temperature (Degree C)"),
							self.tr("Surface emissivity (rel.)"),
							self.tr("Latent heat flux (W.m-2)"),
							self.tr("Latent heat flux - Penman pot. (W.m-2)"),
							self.tr("Latent heat flux - Priestley-Taylor (W.m-2)"),
							self.tr("Sensible heat flux (W.m-2)"),
							self.tr("Ground heat flux (W.m-2)"),
							self.tr("Evapotranspiration intensity (mmol.m-2.s-1)"),
							self.tr("Evaporative fraction (rel.)"),
							self.tr("Bowen ratio (-)"),
							self.tr("Decoupling coefficient (rel.)"),
							self.tr("CWSI (-)"),
							self.tr("Friction velocity (m.s-1)"),
							self.tr("Aerodynamic surface resistance (s.m-1)"),
							self.tr("Resistance for water vapour transfer (s.m-1)"),
							self.tr("NDVI (-)"),
							self.tr("MSAVI (-)"),
							self.tr("NDMI (-)"),
							self.tr("Slope (Degree)"),
							self.tr("Aspect (Degree)")]
									
		self.out_fnames_all = ["Rs_in", "Rs_out", "albedo", 
							   "RL_in", "RL_emit", "Rn", 
							   "Ts", "emis", "LE", "LEp", 
							   "LE_PT", "H", "G", "E_int", 
							   "EF", "Bowen", "omega",
							   "CWSI", "frict_U", "ra",
							   "rc", "NDVI", "MSAVI",
							   "NDMI", "slope", "aspect"]
									
		
		# Loop for creation boolean list of output lyrs
		for i in self.out_chbox_list:
			if i.isChecked():
				self.out_lyrs_list.append(True)
			else:
				self.out_lyrs_list.append(False)
				
		# Loop for creation list of selected variables description
		i = 0
		for j in self.out_names_all:
			if self.out_lyrs_list[i] == True:
				self.out_lyrs_descr.append(self.out_names_all[i])
			i = i + 1
		
		# Loop for creation list of selected output file names
		i = 0
		for j in self.out_fnames_all:
			if self.out_lyrs_list[i] == True:
				self.out_lyrs_fnames.append(self.out_fnames_all[i])
			i = i + 1
	
		return self.out_lyrs_descr, self.out_lyrs_fnames		
		
	def outputsFormat(self, comboBox):
		"""Returns the driver code, output format description (used 
		in the log file) and suffix for the output file/s.
		
		"""
		
		driver_list = ["ENVI", "HFA", "RST","GTiff"]		# GDAL driver for output files
		
		out_formats = ["ENVI (*.hdr)", 						# Names of output format
					   "Erdas Imagine (*.img)",
					   "Idrisi Raster (*.RST)",
					   "TIFF/BigTIFF/GeoTIFF (*.tif)"]
		
		out_suffixes = ["", ".img", ".rst", ".tif"]			# Suffixes of output names
		
		form_ind = comboBox.currentIndex()
		driver = driver_list[form_ind]
		out_form = out_formats[form_ind]
		out_suffix = out_suffixes[form_ind]
		
		return driver, out_form, out_suffix
				
	
	def imagerySystemType(self):
		"""Definition of calculation method"""
		
		if self.dlg.cb_systems.currentIndex() == 0:
			rb_sat = "L5"
		elif self.dlg.cb_systems.currentIndex() == 1:
			rb_sat = "L7"
		elif self.dlg.cb_systems.currentIndex() == 2:
			rb_sat = "L8"
		elif self.dlg.cb_systems.currentIndex() == 3:
			rb_sat = "other"
		else:
			rb_sat = "other"
		
		return rb_sat
		
		
	def settingsLog(self):
		"""Creating log of settings."""
		
		# List of inputs
		inputs = [self.tr("Method of computing: ") + self.rb_method,
				self.tr("Satellite type: ") + self.rb_sat,
				"",
				self.tr("Raster layers"),
				self.tr("Blue band: ") + self.blue_path,
				self.tr("Green band: ") + self.green_path,
				self.tr("Red band: ") + self.red_path,
				self.tr("NIR band: ") + self.nir_path,
				self.tr("SWIR1 band: ") + self.swir1_path,
				self.tr("SWIR2 band: ") + self.swir1_path,
				self.tr("Thermal layer: ") + self.thermal_path,			
				self.tr("DMT_path: ") + self.dmt_path,
				self.tr("Air temperature layer: ") + self.ta_path,
				self.tr("Wind speed: ") + self.wind_path,
				self.tr("Min. height of vegetation cover: ") + self.hmin_path,
				self.tr("Max. height of vegetation cover: ") + self.hmax_path,
				self.tr("Canopy heigth") + self.canopy_path,
				self.tr("Mask: ") + self.mask_path,
				self.tr("Albedo: ") + self.albedo_path,
				"",
				self.tr("Emissivity setting: ") + self.emis_rule,
				"",
				self.tr("Values"),						
				self.tr("Global radiation: ") + str(self.glob_rad),
				self.tr("Rel. humidity: ") + str(self.humid),
				self.tr("Height of wind speed measurement: ") + str(self.hwind),
				"",
				self.tr("Date and time of data acquisition"),
				self.tr("Date: ") + self.acq_date.strftime("%x"),
				self.tr("Time GMT: ") + self.acq_time.strftime("%X"),
				"",
				self.tr("Latitude and longitude of the area"),
				self.tr("Latitude: ") + str(self.latitude),
				self.tr("Longitude: ") + str(self.longitude),
				"",			
				self.tr("Output folder: ") + self.out_folder_path,
				self.tr("Output format: ") + self.out_format]
		
		# Log file path
		self.log_file = os.path.join(self.out_folder_path, "SEBCS_settings_log.txt")
		
		in_export = open(self.log_file, "w")
		
		# Writing inputs
		in_export.write(self.tr("List of input variables") + os.linesep + os.linesep)
		for i in inputs:
			in_export.write(i + os.linesep)
		
		if self.multiband == True:
			in_export.write(self.tr("Output file is multiband") + os.linesep)
			in_export.write(self.tr("Output file name: ") + self.out_file_name + os.linesep)
		
		# Writing outputs	
		in_export.write(os.linesep + self.tr("List of output variables") + os.linesep)
		for i in self.out_lyrs_descr:
			in_export.write(i + os.linesep)
		
		# Writing time of calculation
		calc_time = time.strftime("%x %X")
		in_export.write(os.linesep + self.tr("Calculation has been done: ") + str(calc_time)) 
		
		in_export.close()
	
	
	def setInputs(self):
		# Calculation method
		self.rb_method = self.setMethod() 
		
		# Satellite type
		self.rb_sat = self.imagerySystemType() 

		# Paths to selected files
		self.blue_path = self.pathToLyr(self.dlg.cb_blue)
		self.green_path = self.pathToLyr(self.dlg.cb_green)
		self.red_path = self.pathToLyr(self.dlg.cb_red)
		self.nir_path = self.pathToLyr(self.dlg.cb_nir)
		self.swir1_path = self.pathToLyr(self.dlg.cb_swir1)
		self.swir2_path = self.pathToLyr(self.dlg.cb_swir2)
		self.thermal_path = self.pathToLyr(self.dlg.cb_ts_layer)
		self.dmt_path = self.pathToLyr(self.dlg.cb_dmt)
		self.ta_path = self.pathToLyr(self.dlg.cb_ta)
		self.wind_path = self.pathToLyr(self.dlg.cb_wind)
		self.hmin_path = self.pathToLyr(self.dlg.cb_hmin)
		self.hmax_path = self.pathToLyr(self.dlg.cb_hmax)
		self.canopy_path = self.pathToLyr(self.dlg.cb_canopy)
		self.mask_path = self.pathToLyr(self.dlg.cb_mask)
		self.albedo_path = self.pathToLyr(self.dlg.cb_albedo)
		
		self.in_lyrs_list = [self.blue_path,			# List of the selected input layers
							 self.green_path,
							 self.red_path,
							 self.nir_path,
							 self.swir1_path,
							 self.swir2_path,
							 self.thermal_path,
							 self.dmt_path,
							 self.ta_path,
							 self.wind_path,
							 self.hmin_path,
							 self.hmax_path,
							 self.canopy_path,
							 self.mask_path,
							 self.albedo_path]	
		
		# Values
		self.emis_rule = self.dlg.cb_emiss.currentText()
		self.glob_rad = self.dlg.dsb_global.value()			# float
		self.humid = self.dlg.dsb_humid.value()				# float
		self.hwind = self.dlg.dsb_hwind.value()				# float, heigth of wind speed measurement
					
		# Date and Time
		self.acq_date_qdat = self.dlg.dateEdit.date()			# QDat format
		self.acq_date = self.acq_date_qdat.toPyDate()			# datetime.date format
		
		self.acq_time_qtime = self.dlg.timeEdit.time()			# QTime format
		self.acq_time = self.acq_time_qtime.toPyTime()			# datetime format
		
		# Lat and Long
		self.latitude = self.dlg.dsb_lat.value()
		self.longitude = self.dlg.dsb_long.value()
		
		# Output folder --> path from lineEdit
		self.out_folder_path = self.dlg.le_out_folder.text()
		
		# Output name and multiband setting
		self.multiband, self.out_file_name = self.getOutputName()

		# Set lists of description (out_lyrs_descr) and names (self.out_lyrs_fnames)
		# of the output layers		
		self.out_lyrs_descr, self.out_lyrs_fnames = self.outputsList()
	
		# Set output format
		self.out_driver, self.out_format, self.out_suffix = self.outputsFormat(self.dlg.cb_out_format)
		
		
	def calculate(self):	
		# Run SEBCS
		scs.SEBCS_SA(self.red_path, self.nir_path, self.thermal_path, self.dmt_path, self.ta_path,
				self.glob_rad, self.humid, self.latitude, self.longitude, self.acq_date, self.acq_time,
				self.out_lyrs_fnames, self.out_folder_path, self.out_file_name,
				self.rb_method, self.rb_sat, self.emis_rule, self.out_driver, self.multiband,
				self.blue_path, self.green_path, self.swir1_path, self.swir2_path,
				self.wind_path, self.hmin_path, self.hmax_path, self.mask_path, self.albedo_path, self.canopy_path,
				self.hwind, Z = 200, cp = 1012)

		
	def loadRasters(self):
		"""Uploading of the results (calculated layers) in to the QGIS legend.
		"""
		
		self.out_driver, self.out_format, self.out_suffix = self.outputsFormat(self.dlg.cb_out_format)
		
		# List of output files paths
		for i in range(0, len(self.out_lyrs_fnames)):
			try:
				out_file = os.path.join(self.out_folder_path, 
										self.out_lyrs_fnames[i] + self.out_suffix)		# construction of the path to the resulted layer
				self.iface.addRasterLayer(out_file, self.out_lyrs_fnames[i])									# opening the resulted layer
			except:
				self.iface.messageBar().pushMessage("Info",
								self.tr("File " + self.out_lyrs_fnames[i] + " has not been uploaded in to QGIS."),
								level = Qgis.Warning)
		self.iface.messageBar().clearWidgets()	
		
		
	def progbar(self):
		# Start progressbar
		self.progressMessageBar = self.iface.messageBar().createMessage(self.tr("SEBCS calculation in progress. Please wait a minute."))
		self.progress = QProgressBar()
		self.progress.setMinimum(0)
		self.progress.setMaximum(1)
		self.progress.setAlignment(Qt.AlignLeft|Qt.AlignVCenter)
		self.progressMessageBar.layout().addWidget(self.progress)
		self.iface.messageBar().pushWidget(self.progressMessageBar, Qgis.Info)

	
	def onStart(self):
		self.progress.setMinimum(0)
		self.progress.setMaximum(0)
		self.WT.start()
				
	
	def onFinished(self):
		self.progress.setMinimum(0)
		self.progress.setMaximum(1)
		
		# Reset settings
		self.reset()
		
		# Create finish message and load lyrs 
		self.iface.messageBar().clearWidgets()
		widget = self.iface.messageBar().createMessage("Info", self.tr("Calculation has been done. Do you want to load calculated layers in to QGIS?"))
		button = QPushButton(widget)
		button.setText(self.tr("Load layers"))
		button.pressed.connect(self.loadRasters)
		widget.layout().addWidget(button)
		self.iface.messageBar().pushWidget(widget, Qgis.Info)		
		

class WorkingThread(QtCore.QThread):
	taskFinished = QtCore.pyqtSignal()
	def __init__(self, function):
		QtCore.QThread.__init__(self)
		self.function = function
		
	def run(self):
		self.function()
		self.taskFinished.emit() 
